\section{A Minimal Algebraic Effects Framework in Agda}

In this section, we define a minimal algebraic effects framework in Agda, which we will use to implement CP in the next section.
%
No prior knowledge of algebraic effects is assumed, and we introduce every concept as we go.
%
Algebraic effects provide an abstraction for defining and interpreting effectful computations with a solid foundation in category theory.
%
Each concept is first introduced from a mathematical perspective and then related to programming.
%
We also use stateful computations as an example to demonstrate the use of each concept.
%
Our presentation is influenced by \citet{bauer-2019} and \citet{kidney-2023} but is minimized for our purpose.

\begin{code}[hide]
open import Data.Product using (Î£; Î£-syntax; _,_)
open import Effect.Applicative using (RawApplicative)
open import Effect.Functor using (RawFunctor)
open import Effect.Monad using (RawMonad)
open import Function using (_âˆ˜_; _âˆ˜â€²_; _$â€²_)
open import Level using (Level)

infix 21 âŸ¦_âŸ§
\end{code}

\begin{code}[hide]
-- the standard library `mkRawMonad` is not general enough for our use
-- so we define our own version
module _ where

  private
    variable
      f g : Level

  open RawFunctor
  open RawApplicative
  open RawMonad

  mkRawApplicative :
    (F : Set f â†’ Set g) â†’
    (pure : âˆ€ {A} â†’ A â†’ F A) â†’
    (app : âˆ€ {A B} â†’ F (A â†’ B) â†’ F A â†’ F B) â†’
    RawApplicative F
  mkRawApplicative F pure app .rawFunctor ._<$>_ = app âˆ˜â€² pure
  mkRawApplicative F pure app .pure = pure
  mkRawApplicative F pure app ._<*>_ = app

  mkRawMonad :
    (F : Set f â†’ Set g) â†’
    (pure : âˆ€ {A} â†’ A â†’ F A) â†’
    (bind : âˆ€ {A B} â†’ F A â†’ (A â†’ F B) â†’ F B) â†’
    RawMonad F
  mkRawMonad F pure _>>=_ .rawApplicative =
    mkRawApplicative _ pure $â€² Î» mf mx â†’ do
      f â† mf
      x â† mx
      pure (f x)
  mkRawMonad F pure _>>=_ ._>>=_ = _>>=_
\end{code}

\subsection{Signatures and Algebras}

An effect signature \textit{Sig}, or simply signature, specifies the interface of an effectful computation, which includes a type \textit{Op} of operations and a \textit{Arity} function giving the arity of each operation:
%
\begin{center}\begin{code}
record Sig : Setâ‚‚ where
  constructor _â—_
  field
    Op : Setâ‚
    Arity : Op â†’ Set
\end{code}\end{center}
%
\begin{code}[hide]
open Sig
\end{code}

A signature $\mathbb{F}$ induces a functor $[\![ \mathbb{F} ]\!]$ that interprets all the operations as functions on a carrier set $X$:
%
\begin{center}\begin{code}
âŸ¦_âŸ§ : Sig â†’ Setâ‚ â†’ Setâ‚
âŸ¦ Op â— Ar âŸ§ X = Î£[ o âˆˆ Op ] (Ar o â†’ X)

_-Alg[_] : Sig â†’ Setâ‚ â†’ Setâ‚
ğ”½ -Alg[ X ] = âŸ¦ ğ”½ âŸ§ X â†’ X
\end{code}\end{center}

\subsection{Free Algebras}

\begin{center}\begin{code}
data Term (ğ”½ : Sig) (A : Set) : Setâ‚ where
  var : A â†’ Term ğ”½ A
  op : âŸ¦ ğ”½ âŸ§ (Term ğ”½ A) â†’ Term ğ”½ A

perform : âˆ€ {ğ”½} (o : Op ğ”½) â†’ Term ğ”½ (Arity ğ”½ o)
perform o = op (o , var)

return : âˆ€ {ğ”½} {A} â†’ A â†’ TermÂ ğ”½ A
return = var

_>>=_ : âˆ€ {ğ”½} {A B} â†’ Term ğ”½ A â†’ (A â†’ Term ğ”½ B) â†’ Term ğ”½ B
var x      >>= f = f x
op (o , k) >>= f = op (o , _>>= f âˆ˜ k)
\end{code}\end{center}

\begin{code}[hide]
instance
  term-monad : âˆ€ {ğ”½} â†’ RawMonad (Term ğ”½)
  term-monad = mkRawMonad _ return _>>=_ 
\end{code}

\subsection{Effect Handlers}

\begin{center}\begin{code}
interp : âˆ€ {ğ”½} {X A} â†’ ğ”½ -Alg[ X ] â†’ (A â†’ X) â†’ Term ğ”½ A â†’ X
interp alg f (var x)      = f x
interp alg f (op (o , k)) = alg (o , interp alg f âˆ˜ k)
\end{code}\end{center}
