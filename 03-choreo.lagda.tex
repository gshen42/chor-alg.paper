\section{Choreographic Programming with Algebraic Effects}
\label{sec:cp-alg-eff}

In this section, we use the algebraic effects framework from the previous section to implement a CP language.
%
Due to lack of space, we only consider a minimum CP language with only local computations and communication, omitting features like conditionals and recursion for now.
%
We start by defining processes~(\Cref{sec:process}), which are the results of endpoint projection.
%
Then, we move on to defining choreographies~(\Cref{sec:choreo}).
%
Unlike previous library-level CP languages, our choreographies abstract over a particular representation of located values, allowing us to erase them and avoid non-totality.
%
Finally, we define endpoint projection as location-specific effect handlers for choreographies~(\Cref{sec:epp}).

We assume a local language of signature ð•ƒ that each node uses for local computations, and we parameterize our CP language by it.
%
We use locations Loc to refer to nodes in a distributed system and define them as Strings.
%
However, any data type with decidable equality would suffice.

\begin{code}[hide]
open import 02-algeff hiding (return; _>>=_)

module 03-choreo (ð•ƒ : Sig) where

open import Data.Product using (_,_)
open import Data.String as String using(String)
open import Effect.Monad using (RawMonad)
open import Level using (Level; SetÏ‰)
open import Relation.Binary.PropositionalEquality using (_â‰¡_)
open import Relation.Nullary using (Dec; yes; no)

open RawMonad â¦ƒ...â¦„

infix 20 _â–·_
infix 20 _â‡’_â—‡_
Loc : Set
Loc = String

-- the opaque prevents Agda from unfolding the definition, making the code more readable in certain cases
opaque
  _â‰Ÿ_ : (l lâ€² : Loc) â†’ Dec (l â‰¡ lâ€²)
  _â‰Ÿ_ = String._â‰Ÿ_

-- the stdlib's âŠ¤ is not universe-polymorphic
record âŠ¤ {â„“ : Level} : Set â„“ where
  constructor tt
\end{code}

\subsection{Processes}
\label{sec:process}

\begin{code}[hide]
-- a seperate modules avoid name conflicts
module Process where
\end{code}

\begin{figure}[ht]

\begin{minipage}{.45\textwidth}
  \begin{center}\begin{code}
  data Op : Setâ‚ where
    `locally : âˆ€ {A} â†’ Term ð•ƒ A â†’ Op
    `send    : âˆ€ {A : Set} â†’ Loc â†’ A â†’ Op
    `recv    : âˆ€ {A : Set} â†’ Loc â†’ Op

  Arity : Op â†’ Set
  Arity (`locally {A} _) = A
  Arity (`send _ _) = âŠ¤
  Arity (`recv {A} _) = A

  â„™ : Sig
  â„™ = Op â— Arity
  \end{code}\end{center}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{.45\textwidth}
  \begin{center}\begin{code}
  Process : Set â†’ Setâ‚
  Process A = Term â„™ A

  locally : âˆ€ {A} â†’ Term ð•ƒ A â†’ Process A
  locally t = perform (`locally t)

  send : âˆ€ {A} â†’ Loc â†’ A â†’ Process âŠ¤
  send l a = perform (`send l a)

  recv : âˆ€ {A} â†’ Loc â†’ Process A
  recv {A} l = perform (`recv {A} l)
  \end{code}\end{center}
\end{minipage}

\caption{Processes as Algebraic Effects}
\label{fig:process}
\end{figure}

\Cref{fig:process} presents processes as algebraic effects.
%
Signature â„™ specifies the three operations of processes and their arity:
%
\begin{itemize}
\item
  \AgdaInductiveConstructor{`locally} performs a local computation of type \AgdaDatatype{Term} ð•ƒ $A$ and returns a value of type $A$.
\item
  \AgdaInductiveConstructor{`send} sends a message of type $A$ to a location and returns a unit value.
\item
  \AgdaInductiveConstructor{`recv} receives a message from a location and returns a value of type $A$.
  %
  Here, the performer of the \AgdaInductiveConstructor{`recv} needs to specify what type of value it is expected to receive.
\end{itemize}
%
We also define \AgdaDatatype{Process} as a shorthand for terms using operations from â„™. Finally, we define the helper functions \AgdaFunction{send}, \AgdaFunction{receive}, and \AgdaFunction{locally}.

\subsection{Choreographies}
\label{sec:choreo}

\begin{figure}[ht]

\begin{minipage}{.45\textwidth}
  \begin{center}\begin{code}
At : SetÏ‰
At = âˆ€ {â„“} â†’ Set â„“ â†’ Loc â†’ Set â„“

focus : Loc â†’ At
focus l A s with l â‰Ÿ s
... | yes _  = A
... | no  _  = âŠ¤

module _ (_ï¼ _ : At) where

  data Op : Setâ‚ where
    `comm :  âˆ€ {A} (s r : Loc) â†’
             (Term ð•ƒ A) ï¼  s â†’ Op

  Arity : Op â†’ Set _
  Arity (`comm {A} _ r _) = A ï¼  r

  â„‚ : Sig
  â„‚ = Op â— Arity
  -- the module ends here
  \end{code}\end{center}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{.45\textwidth}
  \begin{center}\begin{code}
Choreo : (At â†’ Set) â†’ SetÏ‰
Choreo F =
  âˆ€ {_ï¼ _ : At}
  {{_ : âˆ€ {â„“} {l} â†’ RawMonad {â„“} (_ï¼  l)}} â†’
  Term (â„‚ _ï¼ _) (F _ï¼ _)

_â–·_ :  âˆ€ {_ï¼ _ : At} {A} â†’
       (s : Loc) â†’ (Term ð•ƒ A) ï¼  s â†’
       Term (â„‚ _ï¼ _) (A ï¼  s)
s â–· t = perform (`comm s s t)

_â‡’_â—‡_ :  âˆ€ {_ï¼ _ : At} {A} â†’
         (s r : Loc) â†’ (Term ð•ƒ A) ï¼  s â†’
         Term (â„‚ _ï¼ _) (A ï¼  r)
s â‡’ r â—‡ t = perform (`comm s r t)
  \end{code}\end{center}
\end{minipage}

\begin{code}[hide]
id-monad : âˆ€ {â„“} â†’ RawMonad {â„“} (Î» A â†’ A)
id-monad = mkRawMonad _ (Î» x â†’ x) (Î» x f â†’ f x)

top-monad : âˆ€ {â„“ â„“â€²} â†’ RawMonad {â„“} {â„“â€²} (Î» A â†’ âŠ¤)
top-monad = mkRawMonad _ (Î» _ â†’ tt) (Î» _ _ â†’ tt)

instance
  focus-monad : âˆ€ {â„“} {l s} â†’ RawMonad {â„“} (Î» A â†’ focus l A s)
  focus-monad {l = l} {s = s} with l â‰Ÿ s
  ... | yes _ = id-monad
  ... | no  _ = top-monad
\end{code}

\caption{Choreographies as Algebraic Effects}
\label{fig:choreo}
\end{figure}

\Cref{fig:choreo} presents choreographies as algebraic effects.
%
One issue that every library-level CP language needs to deal with is how to represent located values.
%
Located values are variables in a choreography that denote values at different locations.
%
We give them types $A \ @ \ l$, which intuitively means a value of type $A$ at location $l$.

Existing library-level CP languages such as HasChor~\citep{shen-2023} define located values as a union of a plain value and a unit value --- an option type --- and have the unspoken invariant that when projecting to location $l$, values at $l$ are a plain value, and otherwise, a unit value.
%
Internally, HasChor uses an unwrap function to extract the plain value from the union.
%
The unwrap function is non-total because the union could be a unit value, but HasChor meticulously use it only in situations where the union is a plain value (implicitly use the invariant), so the non-totality never shows up.
%
This approach does not work in Agda, as it demands that every function be total.
%
For this reason, we take an alternative approach to located values, in which they are kept abstract and erased before projection in a way that respects the invariant by construction.
%
We first define \AgdaFunction{At}, a type-level function that captures the interface of located values.
%
Then, we define \AgdaFunction{focus}, a particular \AgdaFunction{At} that we will use in endpoint projection (we will show another \AgdaFunction{At} in the next section).
%
Intuitively, \AgdaFunction{focus} $l$ erases a located value of type $A \ @ \ s$ to $A$ if $l$ is equal to $s$; otherwise, to a unit value.

The signature â„‚ specifies the two main operations of choreographies using one overloaded constructor:
%
\begin{itemize}
\item
  \AgdaInductiveConstructor{`comm} $s$ $s$ $t$ denotes a local computation $t$ at location $s$.
\item
  \AgdaInductiveConstructor{`comm} $s$ $r$ $t$ denotes location $s$ sends the result of a computation $t$ to location $r$.
\end{itemize}

We also define \AgdaFunction{Choreo} as a shorthand for terms using operations from â„‚ abstracted over a particular \AgdaFunction{At}.
%
We also require \AgdaFunction{At} to be an instance of monads for any location $l$, which allows us to chain together located values.
%
Our focus is a monad because the identity functor and units are both monads.
%
We also define two helpful functions, \AgdaFunction{\_â–·\_} and \AgdaFunction{\_â‡’\_â—‡\_}, for writing choreographies.

\subsection{Endpoint Projection} \label{sec:epp}

\begin{code}[hide]
open Process
\end{code}

\begin{figure}[ht]
\begin{code}
epp : âˆ€ {F} â†’ Choreo F â†’ (l : Loc) â†’ Process (F (focus l))
epp c l = interp alg return c
  where
    alg : âˆ€ {A} â†’ â„‚ (focus l) -Alg[ Process A ]
    alg (`comm s r a , k) with l â‰Ÿ s | l â‰Ÿ r
    ... | yes _  | yes _  = locally a >>= k
    ... | yes _  | no  _  = locally a >>= (Î» x â†’ send r x) >> k tt
    ... | no  _  | yes _  = recv s >>= k
    ... | no  _  | no  _  = k tt
\end{code}
\caption{Endpoint Projection}
\label{fig:epp}
\end{figure}

We can now define endpoint projection, the process of turning a choreography into a process for a target location.
%
\Cref{fig:epp} presents our implementation of EPP.
%
The function \AgdaFunction{epp} takes a choreography $c$ and a target location $l$, and uses the effect handler \AgdaFunction{interp} to interpret operations in $c$.
%
For variables, we return them in the generated process.
%
For operations, we construct a \AgdaFunction{â„‚}-Algebra (with all located values erased from $l$'s perspective) \AgdaFunction{alg} on processes, which does one step of interpretation.
%
The only operation we need to interpret is \AgdaInductiveConstructor{`comm}, depending on whether $l$ is equal to $s$ and $r$:
%
\begin{itemize}
\item
  If $l$ equals $s$ and $r$, meaning $s$ and $r$ are the same, we interpret this operation as a local computation followed by the continuation.
\item
  If $l$ equals $s$ but not $r$, meaning the target location is the sender, we interpret the operation as a local computation followed by a send and the continuation.
\item
  If $l$ equals $r$ but not $s$, meaning the target location is the receiver, we interpret the operation as a receive followed by the continuation.
\item
  If $l$ equals neither $s$ nor $r$, meaning the target location is not involved, we just return the continuation.
\end{itemize}
