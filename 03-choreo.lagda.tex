\section{Choreographic Programming with Algebraic Effects}

In this section, we use the algebraic effects framework from previous section to implement a CP language.

\begin{code}[hide]
open import 02-algeff hiding (return; _>>=_)

module 03-choreo (ð•ƒ : Sig) where

open import Data.Product using (_,_)
open import Data.String as String using(String)
open import Effect.Monad using (RawMonad)
open import Level using (Level; SetÏ‰)
open import Relation.Binary.PropositionalEquality using (_â‰¡_)
open import Relation.Nullary using (Dec; yes; no)

open RawMonad â¦ƒ...â¦„

Loc : Set
Loc = String

-- the opaque prevents Agda from unfolding the definition, making the code more readable in certain cases
opaque
  _â‰Ÿ_ : (l lâ€² : Loc) â†’ Dec (l â‰¡ lâ€²)
  _â‰Ÿ_ = String._â‰Ÿ_

-- the stdlib's âŠ¤ is not universe-polymorphic
record âŠ¤ {â„“ : Level} : Set â„“ where
  constructor tt
\end{code}

\subsection{Processes}

\begin{code}[hide]
-- a seperate modules avoid name conflicts
module Process where
\end{code}

\begin{code}
  data Op : Setâ‚ where
    `locally : âˆ€ {A} â†’ Term ð•ƒ A â†’ Op
    `send    : âˆ€ {A : Set} â†’ Loc â†’ A â†’ Op
    `recv    : âˆ€ {A : Set} â†’ Loc â†’ Op

  Arity : Op â†’ Set
  Arity (`locally {A} _) = A
  Arity (`send _ _) = âŠ¤
  Arity (`recv {A} _) = A

  â„™ : Sig
  â„™ = Op â— Arity

  Process : Set â†’ Setâ‚
  Process A = Term â„™ A
\end{code}  

\subsection{Choreography}

\begin{code}
At : SetÏ‰
At = âˆ€ {â„“} â†’ Set â„“ â†’ Loc â†’ Set â„“
\end{code}

\begin{code}
module _ (_ï¼ _ : At) where

  data Op : Setâ‚ where
    `comm : âˆ€ {A} (s r : Loc) â†’ (Term ð•ƒ A) ï¼  s â†’ Op

  Arity : Op â†’ Set _
  Arity (`comm {A} _ r _) = A ï¼  r

  â„‚ : Sig
  â„‚ = Op â— Arity

Choreo : (At â†’ Set) â†’ SetÏ‰
Choreo F = âˆ€ {_ï¼ _ : At} â†’ Term (â„‚ _ï¼ _) (F _ï¼ _)
\end{code}

\subsection{Endpoint Projection}

\begin{code}[hide]
open Process
\end{code}

\begin{code}
focus : Loc â†’ At
focus l A s with l â‰Ÿ s
... | yes _ = A
... | no  _ = âŠ¤

epp : âˆ€ {F : At â†’ Set} â†’ Choreo F â†’ (l : Loc) â†’ Process (F (focus l))
epp c l = interp alg return c
  where
  alg : âˆ€ {A} â†’ (â„‚ (focus l)) -Alg[ Term â„™ A ]
  alg (`comm s r a , k) with l â‰Ÿ s | l â‰Ÿ r
  ... | yes _ | yes _ = perform (`locally a) >>= k
  ... | yes _ | no  _ = perform (`locally a) >>= (Î» x â†’ perform (`send r x)) >> k tt
  ... | no  _ | yes _ = perform (`recv s) >>= k
  ... | no  _ | no  _ = k tt
\end{code}

\subsection{An Example}
