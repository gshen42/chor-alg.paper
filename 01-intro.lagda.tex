\section{Introduction}

Choreographic programming~(CP)~\citep{montesi-2013, montesi-2023} is a paradigm for programming distributed applications that run on multiple nodes.
%
In CP, instead of programming each node separately, the programmer writes one, unified program, called a \emph{choreography}, that is then compiled to individual programs for each node via a compilation step called \emph{endpoint projection} (EPP).
%
For example, one can implement a distributed pipeline that utilizes the processing power of nodes A, B, and C as a choreography:
%
\begin{equation*}
  \begin{split}
    x \leftarrow \; & \locally{A}{\mathsf{getInput}} \\
    y \leftarrow \; & \comm{A}{B}{\mathsf{process}_A(x)} \\
    z \leftarrow \; & \comm{B}{C}{\mathsf{process}_B(y)} \\
    w \leftarrow \; & \comm{C}{A}{\mathsf{process}_C(z)} \\
                    & \locally{A}{\mathsf{showResults}(w)} \\
  \end{split}
\end{equation*}
%
Here, we use $\leftarrow$ for variable bindings;
%
$\locally{A}{\mathsf{t}}$ denotes a local computation $\mathsf{t}$ at $A$;
%
$\comm{A}{B}{\mathsf{t}}$ denotes communication from $A$ to $B$ with message $\mathsf{t}$.
%
In this choreography, A first gets some input locally, then passes it around to B and C, with each node calling its process function on the data.
%
The result is passed back to A and printed out.
%
To get the deployable implementation for each node, we can apply endpoint projection on the choreography, which generates the following individual programs for A, B, and C:
%
\[
\begin{minipage}{.3\textwidth}
  \begin{equation*}
    \begin{split}
      x \leftarrow \; & \mathsf{getInput} \\
                      & \mathsf{send}(B, \mathsf{process}_A(x)) \\
      w \leftarrow \; & \mathsf{recv}(C) \\
                      & \mathsf{showResult}(w)
    \end{split}
  \end{equation*}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{.3\textwidth}
  \begin{equation*}
    \begin{split}
      y \leftarrow \; & \mathsf{recv}(A) \\
                      & \mathsf{send}(C, \mathsf{process}_B(y)) \\
    \end{split}
  \end{equation*}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{.3\textwidth}
  \begin{equation*}
    \begin{split}
      z \leftarrow \; & \mathsf{recv}(B) \\
                      & \mathsf{send}(A, \mathsf{process}_C(z)) \\
    \end{split}
  \end{equation*}
\end{minipage}
\]
%
A correct CP language guarantees soundness and completeness of EPP, which further implies that the resulting programs are deadlock-free when running together.
%
Prior work has been done on formalizing a core CP calculus and proving its correctness~\citep{cruzfilipe-2020, cruzfilipe-2022, hirsch-2022}.
%
Built on top of these theoretical foundations, several standalone CP languages have emerged~\citep{giallorenzo-2024}, some of them are even verified by a formal reasoning system~\citep{pohjola-2022, cruzfillipe-2023}.
%
And people have been using them to build real-world distributed applications~\citep{lugovic-2023}.

However, these standalone CP languages are not widely applicable as they do not integrate well with existing language infrastructures.
%
They typically build a separate compiler on top of an existing language --- which is already a significant amount of work -- and have limited tooling and IDE support.
%
Also, sometimes they have to reinvent the wheels to implement features like polymorphism, higher-order functions, and asynchrony that is already in the existing language.

Recent efforts have been spent on developing \emph{library-level} CP languages~\citep{shen-2023, kashiwa-2023}.
%
In these languages, choreographies and EPP are completely expressed as constructs in the host language.
%
However, they lack a solid theoretical foundation, especially a formal proof of correctness.

To this end, we propose building a verified library-level CP language using algebraic effects~\citep{plotkin-2003, plotkin-2013}.
%
Algebraic effects provide an abstraction that generalizes previous approaches.
%
They allow us to define choreographies as computations with user-defined effects and EPP as location-specific effect handlers, all at the library level.
%
Algebraic effects also lend themselves to proofs of correctness.
%
They provide abstract syntax trees for choreographies where CP-specific effects and control flows are manifest, enabling reasoning about them.
%
Given that algebraic effects are going mainstream, with efficient implementations, we believe our approach would make library-level CP less ad-hoc and bring it to an even broader audience.

We carry out our verified implementation in the proof assistant Agda and extract a Haskell implementation.
%
The same approach can be easily ported to a different language that supports algebraic effects with confidence in its correctness, given that a model of it has been verified.

In this paper, we outline our plan for building a verified library-level CP language with algebraic effects.
%
In particular, we show how to define choreographies and EPP with algebraic effects in Agda.
%
In the end, we state the correctness condition for EPP and some next steps.
